<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
</body>
</html>
<script>
//练习题1
    console.log(a)//undefined
    var a =12
    function fn() {
        console.log(a)//13
        var a =13 
    }
    fn()
    console.log(a)//12
//练习题2
console.log(a)//undefined
    var a =12
    function fn() {
        console.log(a)//13
         a =13 
    }
    fn()
    console.log(a)//13
//练习题3 代码报错
console.log(a) //ReferenceErroe (引用错误):a is not defined //a还未定义
     a =12
    function fn() {
        console.log(a)
         a =13 
    }
    fn()
    console.log(a)
//练习题4 
    a =12
    function fn() {
        console.log(a)
         a =13 
    }
    fn()
    console.log(a)
 //练习题5
 console.log(1)
 console.log(a)//ReferenceError: Cannot access 'a' before initialization //不能在初始化之前使用a
 let a =12
    function fn() {
        console.log(a)
         let a =13 
    }
    fn()
    console.log(a)
//练习题6 词法解析已经知道在当前私有栈中有一个let a 此时私有栈中的a都是私有的
let a =12
    function fn() {
        console.log(a)//ReferenceError: Cannot access 'a' before initialization //不能在初始化之前使用a
         let a =13 
    }
    fn()
    console.log(a)
//练习题7 let所在的大括号是一个块作用域（私有作用域）
if(1===1) {
    var a = 12 //=>没有块作用域
    let b = 13//=>有块作用域 
}
console.log(a)//=>12
console.log(b)//=>ReferenceErroe (引用错误):b is not defined //b还未定义

//练习题 8 let所在的大括号是一个块作用域（私有作用域） {}
if(1===1) {
    var a = 12 //=>没有块作用域
    let b = 13//=>有块作用域 
    window.b = 14
}
console.log(a)//=>12
console.log(b)//=>14
//练习题9 
var foo = 1 
function bar() {
    if(!foo) {//!undefined=>true
        var foo =10
    }
    console.log(foo)//10
}
bar()
//练习题9 
let foo = 1 
function bar() {
    if(!foo) {//!1=>false
        let foo =10
    }
    console.log(foo)//1
}
bar()

//练习题9 
let foo = 1 
function bar() {
    if(foo) {//true
        let foo =10//块级作用域，这里的foo只能在if里
    }
    console.log(foo)//1
}
bar()
//练习题10
let n =12 
~function () {
    let n =0 
    if(1) {
        n=13 
    }
    console.log(n)//=>13
}()
console.log(n)//=>12

//练习题11
var n = 0 
function a() {
    var n =10 
    function b() {
        n++
        console.log(n)
    }
    b();
    return b;
}
var c = a();//闭包不销毁，a()方法执行一次 输出11 然后将a方法里返回了function b()
c()//执行function b()函数执行完闭包销毁//输出12
console.log(n)
//练习题12
var a=10,b=11,c=12
function test(a) {//形参也是私有变量
    /*
    形参赋值&变量提升
    a=10
    var =b;
    */
   a=1;
   var b= 2
   c=3
}
test(10)
console.log(a)
console.log(b)
console.log(c)
//10 11 3

//练习题13
/*
不管条件是否成立都要进行变量提升
var a;//=>全局下声明了一个变量也相当于给window添加了一个属性
*/
if(!("a" in window)) {
    var a = 1
}
console.log(a) //=>undefined

//练习题14
var a = 4
function b (x,y,a) {
    /*
    形参赋值&变量提升
    x=1
    y=2
    a=3
    在JS非严格模式下，arguments和形参存在映射关系（一个改都会跟着变）
     */
    console.log(a)
    arguments[2]=10//arguments 就是函数的实参集合(箭头函数没有)，一个数组。不管是否定义了形参，也不管传递了多少实参，arguments中包含所有传递的实参信息。
    console.log(a)
}
console.log(a)//undefined 如果函数里没有return返回值 默认返回undefined

//练习题15
// 逻辑或 || 和逻辑与&& 在赋值操作的意义
//A||b :先验证A的真假，如果A为真返回A的值，A为假返回的是B的值
//A&&b :A为真返回B值,A为假返回B的值
//&&的优先级高于 ||
var foo = 'hello'
(function (foo){
    console.log(foo)
    var foo = foo || 'world'//有形参foo了var foo不会再声明了，foo重新赋值！当形参和私有作用域里的变量名重复时以形参为主！
    console.log(foo)
})(foo)//把全局的foo的值hello作为实参传给形参
console.log(foo)

//练习题16
var a =9 
function fn() {
    a=0;
    return function(b) {
        return b+a++
    }
}
var f =fn()
console.log(f(5))
console.log(fn()(5))
console.log(f(5))
console.log(a)
//练习题17
var a = 1 
var obj = {name:'tom'}
function fn() {
    var a2 = a
    obj2 = obj 
    a2 = a 
    obj2.name ='jack'
}
fn()
console.log(a)
console.log(obj)
</script>