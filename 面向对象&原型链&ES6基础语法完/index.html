<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
</body>
</html>
<script>
//练习题1
//构造函数执行，因为也具备普通函数执行的特点：
//1.和实例有关系的操作一定是this.xxx=xxxx，因为this是当前类创建出来的实例
//2.私有变量和实例必然的关系，他们不属于实例，他们只是类的私有变量，实例是无法用的!
function Fn(n) {
    let m = 10
    this.total = n + m
    this.say = function() {
        console.log(this.total)
    }
}
let f1 = new Fn(10)
let f2 = new Fn(20)
let f3 = new Fn //new的时候不论是否加小括号都相当把Fn执行了，也创建了对应的实例，只不过不加小括号不能传值（当前n是undefiend）
console.lo(f1.m)//undefiend
console.log(f2.n)//undefiend
console.log(f1.total)//20
f2.say()//this:f2(因为say执行前面有点) 30
console.log(f1===f2)//false（俩个不同的实例对象。不同的堆地址）

//练习题2
function Fn(){
    this.x = 100
    this.y =200
    this.say=function(){}
}
let f1 = new Fn()
f1.y=300
let f2 = new Fn()


//实现add(2)(3).sum()=5,add(2,3).sum()=5


//练习题3
function Fn() {
    //=>this:f1这个实例
    this.x = 100
    this.y = 200
    this.say = function() {
        //调用时才能确定this
        console.log(this.x)
    }
}
Fn.prototype.say=function() {
    console.log(this.y)
}
Fn.prototype.eat=function() {
    console.log(this.x+y)
}
let f1 = new Fn;
f1.say()//=>this:f1 console.log(f1.x)=>100
f1.eat()//=>this:f1 console.log(f1.x+f1.y)=>300
f1.__proto__.say()//=>this:f1__proto__=>console.log(f1.__proto__.y)=>undefiend
Fn.prototype.eat()//=>this:Fn.prototype =>console.log(Fn.prototype.x+Fn.prototype.y)Nan
Fn.prototype.write = function() {
    this.z = 100
}
f1.write()//=>this:f1=>f1.z=100=>给f1设置一个私有属性z=100
Fn.prototype.write();//this:Fn.prototype=>Fn.prototype.z=100 给Fn.prototype上设置一个属性z=100(这个属性是私立公有的)
/*
面向对象中有关私有/公有中的this问题
1.方法执行，看前面是否有点，点前面是谁this就是谁
2.把方法中的this进行替换
3.再基于原型链查找的方法确定结果即可
*/

//练习题4
/*
基于内置类的原型扩展方法
在内置类原型上的方法,类所定义的实例可以直接调取使用，例如：实例.方法（） ary.push()
如果我们也把自己写的方法放到原型上，那么当前类的实例也可以直接这样调取使用，很方便
需要注意的地方：
1.自己扩展的方法不能影响原型内置的方法（我们自己设置方法最好加前缀:my）
2.扩展方法中的this一般都是当前类的实例（也就是要操作的值）:实例.方法（）
Array.prototype.push=function(){
    console.log('哈哈')
}
let arr = [1,2,3]
ary.push(100)//哈哈哈
console.log(ary)=>数组没变
*/
//数组去重
let ary = [1,32,2,24,3,32,4,24]
function unique(ary) {
    let obj = {}
    for(let i=0;i<ary.length;i++) {
        let item = ary[i]//let 形成一个作用域，let item只会在这里块级作用域被调用
        console.log(obj[item],'---obj[item]---')
        console.log(typeof obj[item] !== 'undefined')
        if(typeof obj[item] !== 'undefined'){
            ary[i]=ary[ary.length-1]//如果obj的属性不等于undefined让当前ary=最后一个
            ary.length--;
            i--
            console.log(i)
            continue;
        }
        obj[item] =item
        console.log(obj,'---obj----')
        console.log(obj[item])
        console.log('===============================')
    }
    obj=null
    return ary
}
//数组去重原理：首先将数组的取出变成对象的属性和属性值，然后再进行对比，当对象有这个属性的时候就让数组的当前项的值等于最后数组的最后一个值，数组再--是为了剔除重复值,i--让为了让i回到找到重复值的索引!continue跳过这个从下一个开始！
unique(ary)
//封装挂在到数组原型上
~function(){
    function myUnique(){
        let obj = {},_this =this;
        for(let i = 0; i<_this.length;i++) {
            let item = _this[i]
            if(typeof obj[item] !== 'undefined') {
                _this[i]=_this[this.length-1]
                _this.length--;
                i--;
                continue
            }
            obj[item]=item 
        }
        obj=null
        return this//保证当前方法执行完毕返回的结果依然是Array类的一个实例，这样就继续使用数组原型上的其他方法。
    }
    Array.prototype.myUnique =myUnique
}()
let ary =[1,1,2,34,54,54]
ary.myUnique()//返回去重的新数组(也是Array类的实例)
//ary.sort((a,b)=>a-b)//返回排序后的数组
ary=ary.myUnique().sort((a,b)=>a-b).reverse().slice(2).push('珠峰').concat(2)//链式调佣
//链式写法（保证返回值依然是当前类的实例 一般都会return this）
//concat is not a function 执行完push返回的是一个数字（新增后数组的长度）,不是数组了。不能继续调用了
console.log(ary)
//练习题 5
function fun(n,o){
    console.log(o)
    return {
        fun:function(m){
            return fun(m,n)
        }
    }
}
var c = fun(0).fun(1)
c.fun(2)
c.fun(3)

</script>